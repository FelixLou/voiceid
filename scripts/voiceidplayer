#!/usr/bin/env python
#############################################################################
#
# VoiceID, Copyright (C) 2011, Sardegna Ricerche.
# Email: labcontdigit@sardegnaricerche.it, michela.fancello@crs4.it, 
#        mauro.mereu@crs4.it
# Web: http://code.google.com/p/voiceid
# Authors: Michela Fancello, Mauro Mereu
#
# This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#############################################################################
#
# VoiceID is a speaker recognition/identification system written in Python,
# based on the LIUM Speaker Diarization framework.
#
# VoiceID can process video or audio files to identify in which slices of 
# time there is a person speaking (diarization); then it examines all those
# segments to identify who is speaking. To do so you must have a voice models
# database. To create the database you have to do a "train phase", in
# interactive mode, by assigning a label to the unknown speakers.
# You can also build yourself the speaker models and put those in the db
# using the scripts to create the gmm files.
#

from voiceid.db import GMMVoiceDB
from voiceid.sr import Voiceid
from wx.lib.mixins.listctrl import CheckListCtrlMixin, ListCtrlAutoWidthMixin
from wx.lib.pubsub import Publisher
import MplayerCtrl as mpc
import os.path
import subprocess
import sys
import threading
import time
import wx
import wx.lib.buttons as buttons
import wx.lib.mixins.listctrl  as  listmix
#dirName = os.path.dirname(os.path.abspath(__file__))
dirName = os.path.join(sys.prefix, 'local/share/voiceid')
bitmapDir = os.path.join(dirName, 'bitmaps')
LIST_ID = 26
PLAY_ID = 1
EDIT_ID = 0
OK_DIALOG = 33
CANCEL_DIALOG = 34
TRAIN_ON = 100
TRAIN_OFF = 101


class Controller:
    """A controller build the window interface and bind it all the control functions

    :type line: App
    :param app: App initializes the application
    """
    
    def __init__(self, app):
        
        self.model = Model()
        
        self.frame = MainFrame()
        
        sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        self.player = Player(self.frame)
        
        self.clusters_list = ClustersList(self.frame)
        
        sizer.Add(self.player, 5, wx.EXPAND)
        
        sizer.Add(self.clusters_list, 2, wx.EXPAND)
        
        self.frame.SetSizer(sizer)
        
        self.frame.Layout()
        
        sp = wx.StandardPaths.Get()
        
        self.currentFolder = sp.GetDocumentsDir()
        
        """ Binding toolbar buttons to control's function """
        self.frame.Bind(wx.EVT_MENU, self.on_add_file, self.frame.add_file_menu_item)
        self.frame.Bind(wx.EVT_MENU, self.on_run, self.frame.run_menu_item)
        self.frame.Bind(wx.EVT_MENU, self.on_save, self.frame.train_menu_item) 
        
        self.player.Bind(wx.EVT_TIMER, self.on_update_playback)

        
        self.clusters_list.list.Bind(ULC.EVT_LIST_COL_CHECKING, self.on_check_col_clusters_list)
        self.clusters_list.list.Bind(ULC.EVT_LIST_ITEM_CHECKED, self.on_check_item_clusters_list)
        
        self.player.colorPanel.Bind(wx.EVT_PAINT, self.draw_selected_clusters)
        
        Publisher().subscribe(self.update_status, "update_status")
        Publisher().subscribe(self.update_list, "update_list")
        
    def on_add_file(self, event):
        
        """Add a Movie and start playing it"""
        
        wildcard = "Media Files (*.*)|*.*"
        json_path = ""
        dlg = wx.FileDialog(
            self.frame, message="Choose a file",
            defaultDir=self.currentFolder,
            defaultFile="",
            wildcard=wildcard,
            style=wx.OPEN | wx.CHANGE_DIR
            )
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            self.currentFolder = os.path.dirname(path[0])
            trackPath = '"%s"' % path.replace("\\", "/")
            self.player.video_path = trackPath
            self.player.mpc.Loadfile(trackPath)
            json_path = os.path.splitext(trackPath)[0]+'.json'
            json_path = json_path.replace('"', '')
            
        self.frame.run_menu_item.Enable(True)
        
        self.clusters_list.clean()
        
        if os.path.exists(json_path):
            self.model.load_json(json_path)
            self.frame.train_menu_item.Enable(True)
            wx.CallAfter(Publisher().sendMessage, "update_list", "Loading finished")
        
     
    def on_extraction_speakers(self):
        """
        Update status bar while extracting speakers
        """
        
        old_status = self.model.get_status()
        wx.CallAfter(Publisher().sendMessage, "update_status", self.model.get_working_status() + " ...")
        while self.model.get_status() < 5:
            time.sleep(2)
            status = self.model.get_status()
            try:
                if status != old_status:
                    old_status = self.model.get_status()
                    wx.CallAfter(Publisher().sendMessage, "update_status", self.model.get_working_status() + " ...")
            except StandardError:
                print "Error in print_logger"
        self.on_finish_extraction_speakers()
        
    def on_finish_extraction_speakers(self):
        """
        Enable Speakere Recognition button
        """
        
        wx.CallAfter(Publisher().sendMessage, "update_status", self.model.get_working_status())
        self.frame.train_menu_item.Enable(True)
        wx.CallAfter(Publisher().sendMessage, "update_list", "Process finished")
        
#----------------------------------------------------------------------
    def update_status(self, msg):
        """
        Receives data from thread and updates the status bar
        """
        self.frame.set_status_text( msg.data )
        
            
    def on_update_playback(self, event):
        """
        Updates playback slider and track counter
        """
        
        try:
            offset = self.player.mpc.GetTimePos()
            #offset = self.player.mpc.GetProperty('time_pos')
        except:
            return
            #print offset
        #r = "%.1f" % round(float(offset), 1)
        mod_off = str(offset)[-1]
        if mod_off == '0':
            #print "mode off"
            offset = int(offset)
            
            self.player.playbackSlider.SetValue(offset)
            secsPlayed = time.strftime('%M:%S', time.gmtime(offset))
            self.player.trackCounter.SetLabel(secsPlayed)
        
        if len(self.clusters_list.list.checked) > 0:  
#            print "play segments"   
            self.on_play_segments(event)
            
    def on_save(self,event):
        """
        Export info to json format
        """
        
        wx.CallAfter(Publisher().sendMessage, "update_status", "Saving changes...")
        self.model.save_changes()
        wx.CallAfter(Publisher().sendMessage, "update_status", "Changes saved")
            
    def on_run(self, event):
        """
        Run Speaker Recognition
        """
        self.clusters_list.clean()
        self.frame.run_menu_item.Enable(False)
        path = self.player.video_path.replace('"', '')
        self.model.load_video(str(path))
        #self.player.video_path
        self.thread_logger = threading.Thread(target=self.on_extraction_speakers)
        self.thread_logger.start()
        
            
        self.thread_extraction = threading.Thread(target=self.model.extract_speakers)
        self.thread_extraction.start()

    def update_list(self, msg):
        """
        Receives data from thread and updates the status bar
        """
        self.clusters_list.clean()
        t = msg.data
        self.frame.set_status_text(t)
        u, k = self.model.get_clusters_info()
        text = "Speakers info:\n " + str(u) + " unknown \n " + str(k) + " known" 
        self.clusters_list.set_info_clusters(text)
        clusters = self.model.get_clusters()
        for c in clusters.values():
            self.clusters_list.add_cluster(c.get_name(), c.get_speaker())

        self.draw_selected_clusters()    

    def on_check_col_clusters_list(self, event):
        
        list_items = self.clusters_list.list 
        
        coloumn = list_items.GetItem(event.m_itemIndex,0)
        
        if list_items.IsItemChecked(coloumn, 0):
            list_items.checked = []
        else:
            for index in range(list_items.GetItemCount()): 
                cluster = list_items.GetItem(index,1)
                list_items.checked.append(cluster.GetText())
            
        self.draw_selected_clusters()
        
        self.init_player_seek()
        
    def on_check_item_clusters_list(self, event):
        
        list_items = self.clusters_list.list    
        
        cluster = list_items.GetItem(event.m_itemIndex,1)
                
        if cluster.GetText() in list_items.checked:
            list_items.checked.remove(cluster.GetText())
        else:
            list_items.checked.append(cluster.GetText())
        
        self.draw_selected_clusters()
        
        self.init_player_seek()

    def exit_(self):
        self.player.mpc.Quit()
        
    def init_player_seek(self):
        if len(self.clusters_list.list.checked) >0:
            self.on_play_clusters()
        else:
            self.player.on_play(None)
        
    def draw_selected_clusters(self, event = None):
        result = []
        list_items = self.clusters_list.list    
        items = list_items.checked
        
        
        for c in items:
            cluster = self.model.get_cluster(c)
            color = self.clusters_list.get_color(c)

            for s in cluster._segments:                
                result.append((s.get_start(), s.get_end(),color))             
        
        wx.CallAfter(self.player.draw_cluster_segs, result)

        
        
    def on_play_clusters(self,event = None):
        
        list_items = self.clusters_list.list    
        start_time = self.model.get_cluster(list_items.checked[0])._segments[0].get_start()
        
        for l in list_items.checked:
            c = self.model.get_cluster(l)
            if c._segments[0].get_start() < start_time:
                start_time = c._segments[0].get_start()
                
        self.player.mpc.Mute(1)
        self.player.mpc.Seek(float(start_time) / 100 , 2)
        self.toggle_pause()
        self.player.mpc.Mute(0)
        self.player.playbackSlider.SetValue(float(start_time) / 100)
        secsPlayed = time.strftime('%M:%S', time.gmtime(start_time))
        self.player.trackCounter.SetLabel(secsPlayed)
        
             
    def on_play_segments(self, event):
        
        list_items = self.clusters_list.list    
        items = list_items.checked
        segments = []
        for c in items:
            cluster = self.model.get_cluster(c)
            segments.extend(cluster._segments[:])
            

        segments = sorted(segments, key = lambda seg: seg._start)
        
        segments_rev = segments[:]
        segments_rev.reverse()   
        offset = self.player.mpc.GetTimePos()
        #print segments    
        n = 0
        for s in segments_rev:
            end = float(s.get_end()) / 100
            #print "offset = %s  end = %s " % (offset, end)
            if offset >= end :
                #print "n %s" % n
                next_ = len(segments) - n
                if  n > 0 :
                    #print "successivo = %s" % next_
                    start = float(segments[ next_ ].get_start()) / 100
                    #print "play at = %s " % start
                    self.player.mpc.Seek(start, 2) 
                    #time.sleep(1)
                else:
                    #print 'pause'
                    self.toggle_pause()
                break
            elif offset >= float(s.get_start()) / 100:
                break
                
            n += 1
                
            #print segments
    def toggle_play(self):
        wx.CallAfter(Publisher().sendMessage, "update_status", "Train ON ...")
        if not self.player.playbackTimer.IsRunning():
            print "toggle play"
            self.player.mpc.Pause()
            self.player.playbackTimer.Start()   
                   
    def toggle_pause(self):
        wx.CallAfter(Publisher().sendMessage, "update_status", "Train OFF ...")
        if self.player.playbackTimer.IsRunning():
            print "toggle pause"
            self.player.mpc.Pause()
            self.player.playbackTimer.Stop()  
            
            
class ClusterForm(wx.Dialog):
    """
    Build a form to insert the correct speaker name
    """
    
    def __init__(self, parent, title):
        
        wx.Dialog.__init__(self, parent, 20, title, wx.DefaultPosition, wx.Size(250, 100))
        
        vbox = wx.BoxSizer(wx.VERTICAL)

        hbox = wx.BoxSizer(wx.HORIZONTAL)
        
        buttonbox = wx.BoxSizer(wx.HORIZONTAL)
        
        fgs = wx.FlexGridSizer(3, 2, 9, 25)

        title = wx.StaticText(self, label="Speaker")

        self.tc1 = wx.TextCtrl(self, size=(150, 25))

        fgs.AddMany([(title), (self.tc1, 1, wx.EXPAND)])

        fgs.AddGrowableRow(2, 1)
        fgs.AddGrowableCol(1, 1)

        hbox.Add(fgs, flag=wx.ALL | wx.EXPAND, border=15)
        self.b_ok = wx.Button(self, label='Ok', id=OK_DIALOG)
        self.b_cancel = wx.Button(self, label='Cancel', id=CANCEL_DIALOG)
        
        buttonbox.Add(self.b_ok, 1, border=15)
        buttonbox.Add(self.b_cancel, 1, border=15)
        
        vbox.Add(hbox, flag=wx.ALIGN_CENTER | wx.ALL | wx.EXPAND)
        vbox.Add(buttonbox, flag=wx.ALIGN_CENTER)
        self.SetSizer(vbox)
        

class MainFrame(wx.Frame):
    """
    Builds an external window that acts as a container
    """
    
    def __init__(self):
        wx.Frame.__init__(self, None, title="Voiceid Player", size=(950, 600))
        self._create_menu()
        self.sb = self.CreateStatusBar()
        self.Show()
        
    def _create_menu(self):
        """
        Creates a menu
        """
        menubar = wx.MenuBar()
        fileMenu = wx.Menu()
        srMenu = wx.Menu()
        srSettings = wx.Menu()
        self.add_file_menu_item = fileMenu.Append(wx.NewId(), "&Open video", "Add Media File")
        self.run_menu_item = srMenu.Append(wx.NewId(), "&Run Recognition")
        self.train_menu_item = srMenu.Append(wx.NewId(), "&Save ")
        self.train_menu_item.Enable(False)
        self.run_menu_item.Enable(False)
        menubar.Append(fileMenu, '&File')
        menubar.Append(srMenu, '&Speaker Recognition')
        #menubar.Append(srSettings, '&Settings')
        self.SetMenuBar(menubar)
        
     
    def set_status_text(self, text):
        #TODO: set status text
        self.sb.SetStatusText(text)
        

class Player(wx.Panel):
    """
    Builds a Player  
    """
    
    def __init__(self, parent):
        wx.Panel.__init__(self, parent, -1)
        self.parent = parent
#        self.SetBackgroundColour("#000")
        self.mpc = mpc.MplayerCtrl(self, 0, u'mplayer')
        self.sizer = wx.BoxSizer(wx.VERTICAL)
        self.controlSizer = self.build_player_controls()
        self.sliderSizer = wx.BoxSizer(wx.HORIZONTAL)
        
        self.colorSizer =  wx.BoxSizer(wx.VERTICAL)
        
        self.playbackSlider = wx.Slider(self, size=wx.DefaultSize)

        self.colorPanel = ColorPanel(self, 99)
        self.colorSizer.Add(self.colorPanel, 1, wx.ALL | wx.EXPAND,0)
        
        # create slider
        
        self.colorSizer.Add(self.playbackSlider, 1, wx.ALL | wx.EXPAND, 0)
        
        self.sliderSizer.Add(self.colorSizer, 1, wx.ALL | wx.EXPAND, 0)
 
        # create track counter
        self.trackCounter = wx.StaticText(self, label="00:00")
        self.sliderSizer.Add(self.trackCounter, 0, wx.ALL | wx.CENTER, 5)
        
        # set up playback timer
        self.playbackTimer = wx.Timer(self)
        
        self.sizer.Add(self.mpc, 1, wx.EXPAND | wx.ALL, 5)
#        self.sizer.Add(self.colorPanel,0, wx.ALL | wx.EXPAND, 5)
        self.sizer.Add(self.sliderSizer, 0, wx.ALL | wx.EXPAND, 5)
        self.sizer.Add(self.controlSizer, 0, wx.ALL | wx.CENTER, 5)
        
        # bind buttons to function control
        self.Bind(mpc.EVT_MEDIA_STARTED, self.on_media_started)
        self.Bind(mpc.EVT_MEDIA_FINISHED, self.on_media_finished)
        self.Bind(mpc.EVT_PROCESS_STARTED, self.on_process_started)
        self.Bind(mpc.EVT_PROCESS_STOPPED, self.on_process_stopped)
        
        self.Bind(wx.EVT_SCROLL_CHANGED, self.update_slider, self.playbackSlider)
        
        self.init_objects()
        
        self.SetSizerAndFit(self.sizer)
        self.sizer.Layout()
    
    
    def init_objects(self):
        self.video_length = 0
        self.video_pos = 0
        self.video_path = None
        
        
        
    
    def draw_cluster_segs(self,segs):
        #print 'draw_cluster_segs'
       
        self.colorPanel.clear()
        
        for s,e,c in segs:
            self.colorPanel.write_slice(float(s) / 100, float(e) / 100, c)
            
    
    def update_slider(self, event):
        
        self.mpc.Seek(self.playbackSlider.GetValue(), 2)
    
    def build_btn(self, btnDict, sizer):
        """"""
        bmp = btnDict['bitmap']
        handler = btnDict['handler']
 
        img = wx.Bitmap(os.path.join(bitmapDir, bmp))
        btn = buttons.GenBitmapButton(self, bitmap=img,
                                      name=btnDict['name'])
        btn.SetInitialSize()
        btn.Bind(wx.EVT_BUTTON, handler)
        sizer.Add(btn, 0, wx.LEFT, 3)
        
    
    def build_player_controls(self):
        """
        Builds the player bar controls
        """
        controlSizer = wx.BoxSizer(wx.HORIZONTAL)
        
      
        btnData = [{'bitmap':'pause.png',
                    'handler':self.on_pause, 'name':'pause'},
                   {'bitmap':'play.png',
                    'handler': self.on_play, 'name':'play'},
                   {'bitmap':'backward.png',
                    'handler':self.on_prev, 'name':'prev'},
                    {'bitmap':'forward.png',
                    'handler':self.on_next, 'name':'next'} 
                   ]
        for btn in btnData:
            self.build_btn(btn, controlSizer)
 
        return controlSizer    


    def getLength(self,filename):   
        def check_output(command): 
            process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True)
            output = process.communicate()
            retcode = process.poll()
            if retcode:
                    raise subprocess.CalledProcessError(retcode, command, output=output[0])
            return output
        
        try:     
            command = """mplayer  -vo null -ao null -frames 0 -identify %s 2>/dev/null |sed -ne '/^ID_/ {s/[]()|&;<>`'"'"'\\!$" []/\\&/g;p}'""" % filename
            result = check_output(command)
            r = result[0].split('\n')
            for row in r:
                if row.startswith("ID_LENGTH"):
                    return row.split("=")[1]
        except Exception,e:
            print  e
        

    def on_media_started(self, event):
        print 'Media started!'
        file = self.video_path
        self.video_length = self.getLength(file)
        self.mpc.SetProperty("loop", 0)
        self.mpc.SetProperty("osdlevel", 0) 
        r = "%.1f" % round(float(self.video_length), 1)
        self.video_length = float(r)
        self.playbackSlider.SetRange(0, self.video_length)
        self.playbackTimer.Start(100) 
        
#        #Pause on start
        if self.playbackTimer.IsRunning():
            self.mpc.Pause()
            self.playbackTimer.Stop()

    def on_media_finished(self, event):
        print 'Media finished!'
        self.playbackTimer.Start()
 
    def on_play(self, event):
        """"""
        if not self.playbackTimer.IsRunning():
            print "playing..."
            self.mpc.Pause()
            self.playbackTimer.Start()
 
 
    def on_pause(self, event):
        """"""
        if self.playbackTimer.IsRunning():
            print "pausing..."
            self.mpc.Pause()
            self.playbackTimer.Stop()

    def on_process_started(self, event):
        print 'Process started!'
 
    def on_process_stopped(self, event):
        print 'Process stopped!'

    def on_next(self, event):
        """"""
        print "forwarding..."
        self.mpc.Seek(5)
       
    def on_prev(self, event):
        """"""
        print "backwarding..."
        self.mpc.Seek(-5)    


import wx.lib.agw.ultimatelistctrl as ULC
        
class CheckListCtrl(ULC.UltimateListCtrl):
    def __init__(self, parent):
        self.parent = parent
        ULC.UltimateListCtrl.__init__(self, parent , agwStyle= ULC.ULC_AUTO_CHECK_CHILD |ULC.ULC_EDIT_LABELS | ULC.ULC_REPORT|ULC.ULC_SINGLE_SEL | ULC.ULC_VRULES|ULC.ULC_HRULES)
        #CheckListCtrlMixin.__init__(self)
        #ListCtrlAutoWidthMixin.__init__(self)
        #self.Bind(ULC.E, self.OnCheck)
        self.checked = []
        
        


class ClustersList(wx.Panel):
    """
    Builds the cluster's list 
    """
    
    def __init__(self, parent):
        wx.Panel.__init__(self, parent, -1, size=(150, 650))
        
        self.parent = parent
        self.list = CheckListCtrl(self)
        self.info = wx.Panel(self)
        self.sizer = wx.BoxSizer(wx.VERTICAL)
        
        self.speakers_GRB = {}
        
        self.buttons_sizer = wx.BoxSizer(wx.HORIZONTAL)

        self.buttons_sizer.ShowItems(False)
        
        self.info.text_info = wx.StaticText(self.info, 1, "")
        
        sb_list = wx.StaticBox(self, label=" Speakers ")
        
        sb_info = wx.StaticBox(self, label=" Info ")
        
        self.boxsizer_list = wx.StaticBoxSizer(sb_list, wx.VERTICAL)
        self.boxsizer_list.Add(self.list, 5, wx.EXPAND | wx.ALL, 2)
        
        self.boxsizer_info = wx.StaticBoxSizer(sb_info, wx.VERTICAL)
        self.boxsizer_info.Add(self.info, 5, wx.EXPAND | wx.ALL, 2)
        #self.boxsizer_info.Add(self.buttons_sizer, 1, wx.ALL | wx.EXPAND)
        
        info = ULC.UltimateListItem()
        info._mask = wx.LIST_MASK_TEXT | wx.LIST_MASK_FORMAT | ULC.ULC_MASK_CHECK
        #info.SetBackgroundColour("white")
        info._kind = 1      
        info._text = 'Speaker'
        info._font= wx.Font(13, wx.ROMAN, wx.NORMAL, wx.BOLD)
        self.list.InsertColumnInfo(0,info)
        self.list.SetColumnWidth(0, 110)
        #self.SetColumnWidth(field_index,175)
        self.list.InsertColumn(1, 'Cluster', wx.LIST_AUTOSIZE)
        self.list.InsertColumn(2, '', wx.LIST_AUTOSIZE)
        
        #self.Bind(ULC.EVT_LIST_ITEM_CHECKING, self.list.OnCheck)
        
        self.list.SetBackgroundColour("white")
        
        
        self.columns = 0
        
        self.sizer.Add(self.boxsizer_info, 2, wx.EXPAND | wx.ALL, 2)
        self.sizer.Add(self.boxsizer_list, 5, wx.EXPAND | wx.ALL, 2)
        
        self.SetSizer(self.sizer)
        self.sizer.Layout()
        
    def add_cluster(self, cluster_label, cluster_speaker):
        
        import random
        def randomColor():
            return (int(random.random()*255),int(random.random()*255),int(random.random()*255))
        
        color = randomColor()
        
        while color in self.speakers_GRB.keys():
            color = randomColor()
        
        self.speakers_GRB[cluster_label] = color
        
        data = {self.columns : (cluster_speaker,cluster_label,"")}
        
        
        for key, d in data.items():
            index = self.list.Append(d)
            self.list.SetItemData(index, key)
        
        item = self.list.GetItem(self.columns,2)
        item2 = self.list.GetItem(self.columns,0)
        
        item.SetMask(ULC.ULC_MASK_BACKCOLOUR)
        item.SetBackgroundColour(wx.Colour(color[0],color[1],color[2]))
        
        self.list.SetItem(item)
        self.list.SetItemKind(item2, 0, 1)
        self.columns+=1
    
        print self.speakers_GRB
    
    def clean(self):
        self.speakers_GRB = {}
        self.columns = 0
        self.list.DeleteAllItems()
        self.list.checked = []
        
    def set_info_clusters(self, text):

        self.info.text_info.SetLabel(text)
     
    
          
    def get_color(self, speaker):
        return self.speakers_GRB[speaker]
    
    
        
class ColorPanel(wx.Panel):
    """
    Draws a graphical representation of clusters
    """
    
    def __init__(self, parent, myid):
        wx.Panel.__init__(self, parent, myid)

        # start the paint event for DrawRectangle() and FloodFill()
        #self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.parent = parent

    def clear(self):
        print "clear"
        self.dc = wx.PaintDC(self)
        self.dc.Clear()
        del self.dc
        
    def write_slice(self, start_time, end_time, color):
        width = self.GetSizeTuple()[0] -5
        time_l = self.parent.video_length
        pixel4sec =  float(width) / float( time_l )
        
        duration = end_time - start_time
        
        self._write_rectangle( start_time * pixel4sec, 10 , duration * pixel4sec, 10, color)  

    def _write_rectangle(self,x,y,w,h, color):
        self.dc = wx.PaintDC(self)
        self.dc.BeginDrawing()
        
        self.dc.SetPen(wx.Pen("BLACK",1))
        # draw a few colorful rectangles ...

        self.dc.SetBrush( wx.Brush(color, wx.SOLID ) )
        self.dc.DrawRectangle(x,y,w,h)
        self.dc.EndDrawing()
        # free up the device context now
        del self.dc
                
class ClusterInfo():
    pass
    

class Model:
    def __init__(self):
        self.voiceid = None
        #self.db = GMMVoiceDB(os.path.expanduser('~/.voiceid/gmm_db'))
        self.db = GMMVoiceDB(os.path.expanduser('~/SpeakerRecognition/voiceid/scripts/smalldb'))
        self._clusters = None
        
    def load_video(self, video_path):        
        self.voiceid = Voiceid(self.db, video_path)
        
    def load_json(self, json_path):
        
        self.voiceid = Voiceid.from_json_file(self.db, json_path)
        self._clusters = self.voiceid.get_clusters()    
        
    def extract_speakers(self):
        self.voiceid.extract_speakers(False, False, 4)
        self._clusters = self.voiceid.get_clusters()

    def get_status(self):
        return self.voiceid.get_status()
    
    def get_working_status(self):
        return self.voiceid.get_working_status()
    
    def get_clusters(self):
        return self.voiceid.get_clusters()
    
    def get_clusters_info(self):
        unknown = 0
        known = 0
        for c in self._clusters:
            if self._clusters[c].get_speaker() == 'unknown':
                unknown += 1
            else:
                known += 1
        return unknown, known
    
    def get_cluster(self, name):
        return self._clusters[name]
        
    def save_changes(self):
        self.voiceid.update_db(1)
        self.voiceid.write_output("json")
    
class App(wx.App):
    def __init__(self, *args, **kwargs):
        wx.App.__init__(self, *args, **kwargs)
        self.controller = Controller(self)
        
    def OnExit(self):
        pass
        #self.controller.exit_()
       
if __name__ == "__main__":
    app = App(redirect=False)
    app.MainLoop()
